# codereview.go — Review & Remediation

TL;DR

- This file is a deliberately small, insecure demo used for an assessment. It contains several high-impact security issues (hardcoded secret, plaintext password storage, logging secrets), concurrency and locking mistakes, poor HTTP API design, and non-idiomatic Go naming. The sections below explain each class of issues, their impact, and prioritized fixes you can include in a real application.

Why this matters

- Secrets or plaintext passwords in source or logs = immediate breach risk.
- Holding write locks for reads or sleeping in request handlers hurts throughput and latency.
- Manual JSON and reflected user input opens injection/XSS risks and produces fragile output.

If you're short on time: prioritize fixes in this order

1. Remove hardcoded secrets and stop logging sensitive data.
2. Hash passwords (bcrypt/Argon2) instead of storing plaintext.
3. Use proper JSON encoding (encoding/json) and set Content-Type headers.
4. Fix locking: use RLock for reads, Lock for writes; keep locks short.
5. Enforce HTTP methods and proper status codes.

---

## Quick facts (what I found)

- Global state: package-level `data` map and `counter` make the code stateful and hard to test.
- Secret in code: `DB_PASS` is hardcoded and logged.
- Passwords stored as plain text in `User.pass`.
- Concurrency: write-locks used where reads are needed; long critical sections.
- API design: handlers accept GET for state changes, manual JSON string building, inconsistent Content-Type.
- Style: mixed exported/unexported fields, non-idiomatic names (underscores), inconsistent handler names.

---

## Prioritized issues (with impact & fixes)

1) Security — High impact

- Problem: Hardcoded DB password and logging it.
	- Impact: Anyone with repo access or logs can retrieve the secret.
	- Fix: Remove `DB_PASS` from source. Read secrets from environment variables or a secrets manager. Example:

```go
dbPass := os.Getenv("DB_PASS")
if dbPass == "" {
		log.Fatal("missing DB_PASS")
}
```

- Problem: Plaintext passwords in `User.pass`.
	- Impact: Password disclosure on leak; non-compliant with security best practices.
	- Fix: Hash passwords with bcrypt and store `PasswordHash` instead. Use `golang.org/x/crypto/bcrypt`.

2) Concurrency & global state — High/Medium impact

- Problem: Global `data` and `counter` plus misuse of mutexes.
	- Impact: Hard to test, may block concurrent readers, potential races.
	- Fix: Encapsulate storage in a `Server` or `Store` type and use `RLock` for reads. Keep lock scope minimal.

3) HTTP design & encoding — Medium impact

- Problem: Manual JSON creation and missing headers.
	- Impact: Invalid JSON, injection risks, poor client interoperability.
	- Fix: Use `encoding/json` and `json.Encoder`. Always set `Content-Type: application/json` for JSON responses.

- Problem: Accepting GET for creating users.
	- Impact: Violates HTTP semantics and may enable CSRF-like attacks.
	- Fix: Accept POST for state changes and verify method with `if r.Method != http.MethodPost { http.Error(w, "method not allowed", http.StatusMethodNotAllowed); return }`.

4) Error handling & logging — Low/Medium impact

- Problem: Ignoring parse errors (e.g., `strconv.Atoi` with `_`).
	- Fix: Check errors and return HTTP 400 on client input errors.

5) Style & naming — Low impact but important for maintainability

- Problem: `User_Name`, `list_all_user` are non-idiomatic.
	- Fix: Use `UserName`, `listAllUsers` or `ListAllUsers` and add JSON tags like `UserName string `json:"user_name"``.

---

## Example small refactor suggestions (code snippets)

- JSON response with proper headers:

```go
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(http.StatusOK)
json.NewEncoder(w).Encode(responseStruct)
```

- Hashing a password with bcrypt:

```go
hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
if err != nil {
		return err
}
// store string(hash) in PasswordHash
```

---

## Action plan you can include with your submission

1. Replace global variables with a `Server` type and an in-memory `Store` that implements a `Storage` interface.
2. Add `encoding/json` for payloads and error responses. Add `Content-Type` headers.
3. Hash passwords and stop logging secrets.
4. Add simple tests for the store (create, get, list) and for the handlers (happy path + 1 error case).
5. Run `gofmt` and `go vet`. Optionally add `golangci-lint` for CI.

---

What I changed

- Rewrote the repository `Readme` into a concise, prioritised, and shareable code-review document with TL;DR, clear severity order, actionable fixes, and small code examples.

Next steps (I can do for you)

- Produce a minimal refactor implementing the top 3 fixes (remove secrets, bcrypt, JSON encoding + method checks).
- Add unit tests for the store and handlers and run them.
- Run `gofmt` and `go vet`, and set up a recommended `golangci-lint` config.

If you want me to implement any of these next steps, tell me which one and I will add it to the todo list and start it.

---

